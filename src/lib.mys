class SemVerError(Error):
    message: string

class Version:
    """A semantic version.

    """

    major: u64
    minor: u64
    patch: u64
    _pre_release: string
    _build_metadata: string

    def __init__(self, version: string):
        """Initialize a version object from given string `version`.

        Raises SemVerError if `version` is not a valid semantic
        version.

        """

        mo = version.match(
            # major, minor and patch
            re"^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)"
            # pre release
            re"(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)"
            re"(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?"
            # build metadata
            re"(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$")

        if mo is None:
            raise SemVerError(f"invalid semantic version '{version}'")

        self.major = u64(mo.group(1))
        self.minor = u64(mo.group(2))
        self.patch = u64(mo.group(3))
        self._pre_release = mo.group(4)
        self._build_metadata = mo.group(5)

    def __eq__(self, other: Version) -> bool:
        return ((self.major == other.major)
                and (self.minor == other.minor)
                and (self.patch == other.patch))

    def __ne__(self, other: Version) -> bool:
        return not (self == other)

    def __lt__(self, other: Version) -> bool:
        if self.major < other.major:
            return True
        elif self.major == other.major:
            if self.minor < other.minor:
                return True
            elif self.minor == other.minor:
                if self.patch < other.patch:
                    return True

        return False

    def __gt__(self, other: Version) -> bool:
        return not (self <= other)

    def __le__(self, other: Version) -> bool:
        return self < other or self == other

    def __ge__(self, other: Version) -> bool:
        return not (self < other)

    def __str__(self) -> string:
        version = f"{self.major}.{self.minor}.{self.patch}"

        if self._pre_release is not None:
            version += f"-{self._pre_release}"

        if self._build_metadata is not None:
            version += f"+{self._build_metadata}"

        return version

@test
def test_version():
    version_string = "1.2.0-rc-4+meta"
    version = Version(version_string)
    assert version.major == 1
    assert version.minor == 2
    assert version.patch == 0
    assert str(version) == version_string

    version_string = "3.1.2"
    version = Version(version_string)
    assert version.major == 3
    assert version.minor == 1
    assert version.patch == 2
    assert str(version) == version_string

    version_string = "100.200.300+foo"
    version = Version(version_string)
    assert version.major == 100
    assert version.minor == 200
    assert version.patch == 300
    assert str(version) == version_string

@test
def test_bad_versions():
    try:
        message = ""
        Version("1.0")
    except SemVerError as err:
        message = err.message

    assert message == "invalid semantic version '1.0'"

    try:
        message = ""
        Version("0.0.0.1")
    except SemVerError as err:
        message = err.message

    assert message == "invalid semantic version '0.0.0.1'"

@test
def test_compare():
    assert Version("1.0.0") > Version("0.0.0")
    assert Version("1.1.0") > Version("1.0.0")
    assert Version("1.1.1") > Version("1.1.0")
    assert not (Version("1.0.0") > Version("1.0.0"))

    assert Version("0.0.0") < Version("1.0.0")
    assert Version("1.0.0") < Version("1.1.0")
    assert Version("1.1.0") < Version("1.1.1")
    assert not (Version("1.0.0") < Version("1.0.0"))

    assert Version("0.1.0") == Version("0.1.0")
    assert Version("0.1.0") != Version("0.2.0")

    assert Version("1.1.0") <= Version("1.1.1")
    assert Version("1.1.1") <= Version("1.1.1")
    assert Version("1.1.1") >= Version("0.1.1")
    assert Version("2.1.1") >= Version("2.1.1")
