class SemVerError(Error):
    message: string

class PreRelease:
    """A semantic version pre-release.

    """

    _value: string

    def __init__(self, value: string):
        """Initialize a pre-release object from given string `value`.

        Raises SemVerError if `value` is not a valid semantic version
        pre-release.

        """

        mo = value.match(
            re"((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)"
            re"(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*)")

        if mo is None:
            raise SemVerError(f"invalid semantic version pre-release '{value}'")

        self._value = mo.group(1)

    def identifiers(self) -> [string]:
        """Returns the idenetifiers (dot separated values). For example, the
        pre-release "alpha.1" has two identifiers, "alpha" and "1".

        """

        return self._value.split(".")

    def __eq__(self, other: PreRelease) -> bool:
        return self._value == str(other)

    def __ne__(self, other: PreRelease) -> bool:
        return not (self == other)

    def __lt__(self, other: PreRelease) -> bool:
        identifiers = self.identifiers()
        other_identifiers = other.identifiers()
        compare_count = min(len(identifiers), len(other_identifiers))

        for i in range(i64(compare_count)):
            is_numeric = identifiers[i].is_numeric()
            is_other_numeric = other_identifiers[i].is_numeric()

            if is_numeric and is_other_numeric:
                numeric = u64(identifiers[i])
                other_numeric = u64(other_identifiers[i])

                if numeric < other_numeric:
                    return True

                if numeric > other_numeric:
                    return False
            elif is_numeric and not is_other_numeric:
                return True
            elif not is_numeric and is_other_numeric:
                return False
            elif identifiers[i] < other_identifiers[i]:
                return True
            elif identifiers[i] > other_identifiers[i]:
                return False

        return len(identifiers) < len(other_identifiers)

    def __gt__(self, other: PreRelease) -> bool:
        return not (self <= other)

    def __le__(self, other: PreRelease) -> bool:
        return self < other or self == other

    def __ge__(self, other: PreRelease) -> bool:
        return not (self < other)

    def __str__(self) -> string:
        return self._value

class BuildMetadata:
    """A semantic version build metadata.

    """

    _value: string

    def __init__(self, value: string):
        """Initialize a build metadata object from given string `value`.

        Raises SemVerError if `value` is not a valid semantic version
        build metadata.

        """

        mo = value.match(re"^([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*)$")

        if mo is None:
            raise SemVerError(f"invalid semantic version build metadata '{value}'")

        self._value = mo.group(1)

    def __str__(self) -> string:
        return self._value

class Version:
    """A semantic version.

    """

    major: u64
    minor: u64
    patch: u64
    pre_release: PreRelease
    build_metadata: BuildMetadata

    def __init__(self, version: string):
        """Initialize a version object from given string `version`.

        Raises SemVerError if `version` is not a valid semantic
        version.

        """

        mo = version.match(
            # major, minor and patch
            re"^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)"
            # pre release
            re"(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)"
            re"(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?"
            # build metadata
            re"(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$")

        if mo is None:
            raise SemVerError(f"invalid semantic version '{version}'")

        self.major = u64(mo.group(1))
        self.minor = u64(mo.group(2))
        self.patch = u64(mo.group(3))

        value = mo.group(4)

        if value is not None:
            self.pre_release = PreRelease(value)
        else:
            self.pre_release = None

        value = mo.group(5)

        if value is not None:
            self.build_metadata = BuildMetadata(value)
        else:
            self.build_metadata = None

    def increment_major(self):
        """Increment major by one. Reset pre-release, build metadata, minor
        and patch.

        """

        self.pre_release = None
        self.build_metadata = None
        self.major += 1
        self.minor = 0
        self.patch = 0

    def increment_minor(self):
        """Increment minor by one. Reset pre-release, build metadata and
        patch.

        """

        self.pre_release = None
        self.build_metadata = None
        self.minor += 1
        self.patch = 0

    def increment_patch(self):
        """Increment patch by one. Reset pre-release and build metadata.

        """

        self.pre_release = None
        self.build_metadata = None
        self.patch += 1

    def __eq__(self, other: Version) -> bool:
        if self.major != other.major:
            return False

        if self.minor != other.minor:
            return False

        if self.patch != other.patch:
            return False

        if self.pre_release is not None and other.pre_release is not None:
            if self.pre_release != other.pre_release:
                return False

        if self.pre_release is not None and other.pre_release is None:
            return False

        if self.pre_release is None and other.pre_release is not None:
            return False

        return True

    def __ne__(self, other: Version) -> bool:
        return not (self == other)

    def __lt__(self, other: Version) -> bool:
        if self.major < other.major:
            return True

        if self.major > other.major:
            return False

        if self.minor < other.minor:
            return True

        if self.minor > other.minor:
            return False

        if self.patch < other.patch:
            return True

        if self.patch > other.patch:
            return False

        if self.pre_release is None and other.pre_release is None:
            return False

        if self.pre_release is not None and other.pre_release is None:
            return True

        if self.pre_release is None and other.pre_release is not None:
            return False

        return self.pre_release < other.pre_release

    def __gt__(self, other: Version) -> bool:
        return not (self <= other)

    def __le__(self, other: Version) -> bool:
        return self < other or self == other

    def __ge__(self, other: Version) -> bool:
        return not (self < other)

    def __str__(self) -> string:
        version = f"{self.major}.{self.minor}.{self.patch}"

        if self.pre_release is not None:
            version += f"-{self.pre_release}"

        if self.build_metadata is not None:
            version += f"+{self.build_metadata}"

        return version

@test
def test_version():
    version_string = "1.2.0-rc-4+meta"
    version = Version(version_string)
    assert version.major == 1
    assert version.minor == 2
    assert version.patch == 0
    assert str(version.pre_release) == "rc-4"
    assert str(version.build_metadata) == "meta"
    assert str(version) == version_string

    version_string = "3.1.2"
    version = Version(version_string)
    assert version.major == 3
    assert version.minor == 1
    assert version.patch == 2
    assert version.pre_release is None
    assert version.build_metadata is None
    assert str(version) == version_string

    version_string = "100.200.300+foo"
    version = Version(version_string)
    assert version.major == 100
    assert version.minor == 200
    assert version.patch == 300
    assert version.pre_release is None
    assert str(version.build_metadata) == "foo"
    assert str(version) == version_string

@test
def test_bad_versions():
    try:
        message = ""
        Version("1.0")
    except SemVerError as err:
        message = err.message

    assert message == "invalid semantic version '1.0'"

    try:
        message = ""
        Version("0.0.0.1")
    except SemVerError as err:
        message = err.message

    assert message == "invalid semantic version '0.0.0.1'"

@test
def test_compare():
    assert Version("1.0.0") > Version("0.0.0")
    assert Version("1.1.0") > Version("1.0.0")
    assert Version("1.1.1") > Version("1.1.0")
    assert not (Version("1.0.0") > Version("1.0.0"))

    assert Version("0.0.0") < Version("1.0.0")
    assert Version("1.0.0") < Version("1.1.0")
    assert Version("1.1.0") < Version("1.1.1")
    assert not (Version("1.0.0") < Version("1.0.0"))

    assert Version("0.1.0") == Version("0.1.0")
    assert Version("0.1.0") != Version("0.2.0")

    assert Version("1.1.0") <= Version("1.1.1")
    assert Version("1.1.1") <= Version("1.1.1")
    assert Version("1.1.1") >= Version("0.1.1")
    assert Version("2.1.1") >= Version("2.1.1")

    assert str(Version("1.0.0-rc4").pre_release) == "rc4"
    assert str(Version("1.0.0+2fd3493b").build_metadata) == "2fd3493b"

    version = Version("1.0.0-rc5+1fd3493b")
    assert version.major == 1
    assert version.minor == 0
    assert version.patch == 0
    assert str(version.pre_release) == "rc5"
    assert str(version.build_metadata) == "1fd3493b"

@test
def test_compare_pre_release():
    assert Version("1.0.0-alpha") < Version("1.0.0-alpha.1")
    assert Version("1.0.0-alpha.1") < Version("1.0.0-alpha.beta")
    assert Version("1.0.0-alpha.beta") < Version("1.0.0-beta")
    assert Version("1.0.0-beta") < Version("1.0.0-beta.2")
    assert Version("1.0.0-beta.2") < Version("1.0.0-beta.11")
    assert Version("1.0.0-beta.11") < Version("1.0.0-rc.1")
    assert Version("1.0.0-rc.1") < Version("1.0.0")

    assert Version("1.0.0-alpha") != Version("1.0.0-alpha.1")
    assert not (Version("1.0.0-alpha") == Version("1.0.0-alpha.1"))
    assert Version("1.0.0") != Version("1.0.0-alpha")
    assert Version("1.0.0-1") != Version("1.0.0")
    assert Version("1.0.0") > Version("1.0.0-rc.1")

    assert PreRelease("alpha") < PreRelease("alpha.1")
    assert PreRelease("alpha.1") < PreRelease("alpha.beta")
    assert PreRelease("alpha.beta") > PreRelease("alpha.1")
    assert PreRelease("alpha.beta") < PreRelease("beta")
    assert PreRelease("beta") > PreRelease("alpha.beta")
    assert PreRelease("beta") < PreRelease("beta.2")
    assert PreRelease("beta.2") < PreRelease("beta.11")
    assert PreRelease("beta.11") < PreRelease("rc.1")

    assert PreRelease("rc.1") == PreRelease("rc.1")
    assert PreRelease("rc.1") != PreRelease("rc.2")
    assert PreRelease("rc.1") < PreRelease("rc.2")
    assert PreRelease("rc.2") > PreRelease("rc.1")
    assert PreRelease("rc.1") <= PreRelease("rc.1")
    assert PreRelease("rc.1") <= PreRelease("rc.2")
    assert PreRelease("rc.2") >= PreRelease("rc.1")
    assert PreRelease("rc.1") >= PreRelease("rc.1")

@test
def test_compare_build_metadata():
    version_1 = Version("0.1.0")
    version_2 = Version("0.1.0+981238912")

    assert version_1 == version_2

@test
def test_pre_release_identifiers():
    assert PreRelease("alpha.1").identifiers() == ["alpha", "1"]

@test
def test_bad_pre_release():
    try:
        message = ""
        PreRelease("")
    except SemVerError as err:
        message = err.message

    assert message == "invalid semantic version pre-release ''"

@test
def test_bad_build_metadata():
    try:
        message = ""
        BuildMetadata("")
    except SemVerError as err:
        message = err.message

    assert message == "invalid semantic version build metadata ''"

@test
def test_increment_major():
    datas = [
        ("0.1.0", "1.0.0"),
        ("1.1.1-123+45", "2.0.0")
    ]

    for current_version, expected_version in datas:
        version = Version(current_version)
        version.increment_major()
        assert version == Version(expected_version)

@test
def test_increment_minor():
    datas = [
        ("0.1.0", "0.2.0"),
        ("1.1.1-123+45", "1.2.0")
    ]

    for current_version, expected_version in datas:
        version = Version(current_version)
        version.increment_minor()
        assert version == Version(expected_version)

@test
def test_increment_patch():
    datas = [
        ("0.1.0", "0.1.1"),
        ("1.1.1-123+45", "1.1.2")
    ]

    for current_version, expected_version in datas:
        version = Version(current_version)
        version.increment_patch()
        assert version == Version(expected_version)
